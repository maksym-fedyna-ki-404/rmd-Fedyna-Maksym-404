-- Supabase SQL schema for Volunteer Event app

-- 1) Users: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ auth.users. –î–æ–¥–∞—Ç–∫–æ–≤—ñ –¥–∞–Ω—ñ –º–æ–∂–Ω–∞ —Ç—Ä–∏–º–∞—Ç–∏ –≤ public.profiles
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  name text,
  avatar_url text,
  bio text,
  city text,
  phone text,
  interests text[] default '{}',
  created_at timestamp with time zone default now()
);

-- 2) Events
create type public.event_status as enum ('upcoming','ongoing','completed','cancelled');

create table if not exists public.events (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text not null,
  start_date timestamp with time zone not null,
  end_date timestamp with time zone not null,
  location text not null,
  category text not null,
  image_url text,
  max_participants int not null default 0,
  current_participants int not null default 0,
  status public.event_status not null default 'upcoming',
  requirements text[] not null default '{}',
  organizer text not null,
  contact_info text not null,
  latitude double precision,
  longitude double precision,
  created_at timestamp with time zone default now()
);

-- 3) Favorites (wishlist)
create table if not exists public.favorites (
  user_id uuid not null references auth.users(id) on delete cascade,
  event_id uuid not null references public.events(id) on delete cascade,
  created_at timestamp with time zone default now(),
  primary key (user_id, event_id)
);

-- 4) Registrations (user -> event)
create table if not exists public.registrations (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  event_id uuid not null references public.events(id) on delete cascade,
  created_at timestamp with time zone default now(),
  unique (user_id, event_id)
);

-- 5) Devices (MQTT) - –æ–ø—Ü—ñ–π–Ω–æ
create table if not exists public.devices (
  id uuid primary key default gen_random_uuid(),
  owner_id uuid references auth.users(id) on delete cascade,
  sensor_id text not null,
  created_at timestamp with time zone default now(),
  unique (owner_id, sensor_id)
);

-- 6) Readings (MQTT) - –æ–ø—Ü—ñ–π–Ω–æ
create table if not exists public.readings (
  id bigint generated by default as identity primary key,
  device_id uuid references public.devices(id) on delete cascade,
  value double precision not null,
  unit text default '¬∞C',
  ts timestamp with time zone default now()
);

-- RLS
alter table public.profiles enable row level security;
alter table public.events enable row level security;
alter table public.favorites enable row level security;
alter table public.registrations enable row level security;
alter table public.devices enable row level security;
alter table public.readings enable row level security;

-- profiles: –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –±–∞—á–∏—Ç—å/–æ–Ω–æ–≤–ª—é—î —Å–≤—ñ–π –ø—Ä–æ—Ñ—ñ–ª—å, –≤—Å—ñ –º–æ–∂—É—Ç—å —á–∏—Ç–∞—Ç–∏ –ø—É–±–ª—ñ—á–Ω—ñ –¥–∞–Ω—ñ
drop policy if exists "profiles_read_all" on public.profiles;
drop policy if exists "profiles_self_modify" on public.profiles;
drop policy if exists "profiles_self_update" on public.profiles;
drop policy if exists "profiles_auth_insert" on public.profiles;
create policy "profiles_read_all" on public.profiles
  for select using (true);
create policy "profiles_self_modify" on public.profiles
  for insert with check (auth.uid() = id);
create policy "profiles_self_update" on public.profiles
  for update using (auth.uid() = id);
-- –î–æ–∑–≤–æ–ª–∏—Ç–∏ –∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–æ–≤–∞–Ω–∏–º —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –ø—Ä–æ—Ñ—ñ–ª—å –¥–ª—è —Å–µ–±–µ
create policy "profiles_auth_insert" on public.profiles
  for insert with check (auth.role() = 'authenticated');

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–æ—Ñ—ñ–ª—é –ø—Ä–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤ auth.users
drop function if exists public.handle_new_user cascade;
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles(id, name, avatar_url)
  values (
    new.id,
    coalesce(new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'full_name', new.email),
    new.raw_user_meta_data->>'avatar_url'
  )
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();

-- events: —á–∏—Ç–∞—Ç–∏ –º–æ–∂—É—Ç—å –≤—Å—ñ, —Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏/—Ä–µ–¥–∞–≥—É–≤–∞—Ç–∏ –ª–∏—à–µ –∞–¥–º—ñ–Ω–∏ (–ø—Ä–æ—Å—Ç–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç: –∑–∞–±–æ—Ä–æ–Ω–∏—Ç–∏ –∑ –∫–ª—ñ—î–Ω—Ç–∞)
drop policy if exists "events_select_all" on public.events;
create policy "events_select_all" on public.events for select using (true);

-- favorites: –ª–∏—à–µ –≤–ª–∞—Å–Ω–∏–∫
drop policy if exists "favorites_owner_select" on public.favorites;
drop policy if exists "favorites_owner_ins" on public.favorites;
drop policy if exists "favorites_owner_del" on public.favorites;
create policy "favorites_owner_select" on public.favorites
  for select using (auth.uid() = user_id);
create policy "favorites_owner_ins" on public.favorites
  for insert with check (auth.uid() = user_id);
create policy "favorites_owner_del" on public.favorites
  for delete using (auth.uid() = user_id);

-- registrations: –ª–∏—à–µ –≤–ª–∞—Å–Ω–∏–∫
drop policy if exists "registrations_owner_select" on public.registrations;
drop policy if exists "registrations_owner_ins" on public.registrations;
drop policy if exists "registrations_owner_del" on public.registrations;
create policy "registrations_owner_select" on public.registrations
  for select using (auth.uid() = user_id);
create policy "registrations_owner_ins" on public.registrations
  for insert with check (auth.uid() = user_id);
create policy "registrations_owner_del" on public.registrations
  for delete using (auth.uid() = user_id);

-- devices & readings: –ª–∏—à–µ –≤–ª–∞—Å–Ω–∏–∫
drop policy if exists "devices_owner" on public.devices;
create policy "devices_owner" on public.devices
  for all using (auth.uid() = owner_id) with check (auth.uid() = owner_id);
drop policy if exists "readings_owner" on public.readings;
create policy "readings_owner" on public.readings
  for all using (
    exists(select 1 from public.devices d where d.id = readings.device_id and d.owner_id = auth.uid())
  ) with check (
    exists(select 1 from public.devices d where d.id = readings.device_id and d.owner_id = auth.uid())
  );

-- RPC –¥–ª—è participants
create or replace function public.increment_participants(p_event_id uuid)
returns void language sql security definer as $$
  update public.events
  set current_participants = current_participants + 1
  where id = p_event_id and current_participants < max_participants;
$$;

create or replace function public.decrement_participants(p_event_id uuid)
returns void language sql security definer as $$
  update public.events
  set current_participants = greatest(current_participants - 1, 0)
  where id = p_event_id;
$$;

-- –°—Ç–≤–æ—Ä–µ–Ω–Ω—è Storage bucket –¥–ª—è –∞–≤–∞—Ç–∞—Ä–æ–∫
-- –¶–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ –≤–∏–∫–æ–Ω–∞—Ç–∏ –≤—Ä—É—á–Ω—É –≤ Supabase Dashboard –∞–±–æ —á–µ—Ä–µ–∑ CLI
-- create policy "Avatar images are publicly accessible" on storage.objects for select using (bucket_id = 'avatars');
-- create policy "Users can upload their own avatar" on storage.objects for insert with check (bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1]);
-- create policy "Users can update their own avatar" on storage.objects for update using (bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1]);
-- create policy "Users can delete their own avatar" on storage.objects for delete using (bucket_id = 'avatars' and auth.uid()::text = (storage.foldername(name))[1]);

-- Sample seed (—Ä–æ–∑–∫–æ–º–µ–Ω—Ç—É–π—Ç–µ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ—ó –ë–î)
-- insert into public.events(title, description, start_date, end_date, location, category, max_participants, organizer, contact_info, status)
-- values ('–ü—Ä–∏–±–∏—Ä–∞–Ω–Ω—è –ø–∞—Ä–∫—É', '–î–æ–ø–æ–º–æ–∂–µ–º–æ –ø—Ä–∏–±—Ä–∞—Ç–∏ –ø–∞—Ä–∫', now() + interval '3 day', now() + interval '3 day' + interval '3 hour', '–ü–∞—Ä–∫ —ñ–º. –®–µ–≤—á–µ–Ω–∫–∞, –õ—å–≤—ñ–≤', '–ï–∫–æ–ª–æ–≥—ñ—è', 30, '–ó–µ–ª–µ–Ω–∏–π –õ—å–≤—ñ–≤', '+380501234567', 'upcoming');


-- RPC: –∞–≥—Ä–µ–≥–æ–≤–∞–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑ —Ä—ñ–≤–Ω—è–º–∏
create or replace function public.get_user_stats(uid uuid)
returns table (
  total_events int,
  total_hours int,
  current_streak int,
  longest_streak int,
  categories text[],
  join_date timestamptz,
  level_name text,
  level_emoji text,
  progress_to_next int,
  progress_percentage double precision
) language plpgsql security definer as $$
declare
  v_total int := 0;
  v_hours int := 0;
  v_join timestamptz := now();
  v_categories text[] := '{}';
  v_level_name text := '–ù–æ–≤–∞—á–æ–∫';
  v_level_emoji text := 'üå±';
  v_progress_to_next int := 0;
  v_progress_percentage double precision := 0;
  v_current_streak int := 0;
  v_longest_streak int := 0;
begin
  -- –∑–∞–≥–∞–ª—å–Ω–∞ –∫-—Å—Ç—å —ñ–≤–µ–Ω—Ç—ñ–≤ —Ç–∞ –≥–æ–¥–∏–Ω–∏ –∑–∞ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—é
  select
    count(*)::int,
    coalesce(sum(greatest(extract(epoch from (e.end_date - e.start_date)) / 3600, 0)), 0)::int,
    min(r.created_at)
  into v_total, v_hours, v_join
  from public.registrations r
  join public.events e on e.id = r.event_id
  where r.user_id = uid;

  -- —Ç–æ–ø –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
  select coalesce((array_agg(cat order by cnt desc))[1:5], '{}')
  into v_categories
  from (
    select e.category as cat, count(*) as cnt
    from public.registrations r
    join public.events e on e.id = r.event_id
    where r.user_id = uid
    group by e.category
  ) t;

  -- –ø—Ä–æ—Å—Ç—ñ —Ä—ñ–≤–Ω—ñ —è–∫ —É –∫–ª—ñ—î–Ω—Ç–∞
  if v_total < 5 then
    v_level_name := '–ù–æ–≤–∞—á–æ–∫'; v_level_emoji := 'üå±'; v_progress_to_next := 5 - v_total; v_progress_percentage := v_total / 5.0;
  elsif v_total < 10 then
    v_level_name := '–í–æ–ª–æ–Ω—Ç–µ—Ä'; v_level_emoji := 'ü§ù'; v_progress_to_next := 10 - v_total; v_progress_percentage := (v_total - 5) / 5.0;
  elsif v_total < 20 then
    v_level_name := '–ü–æ–º—ñ—á–Ω–∏–∫'; v_level_emoji := 'üí™'; v_progress_to_next := 20 - v_total; v_progress_percentage := (v_total - 10) / 10.0;
  elsif v_total < 50 then
    v_level_name := '–ß–µ–º–ø—ñ–æ–Ω'; v_level_emoji := 'üèÜ'; v_progress_to_next := 50 - v_total; v_progress_percentage := (v_total - 20) / 30.0;
  elsif v_total < 100 then
    v_level_name := '–ì–µ—Ä–æ–π'; v_level_emoji := 'ü¶∏'; v_progress_to_next := 100 - v_total; v_progress_percentage := (v_total - 50) / 50.0;
  else
    v_level_name := '–õ–µ–≥–µ–Ω–¥–∞'; v_level_emoji := 'üëë'; v_progress_to_next := 0; v_progress_percentage := 1.0;
  end if;

  -- streaks (—Å–ø—Ä–æ—â–µ–Ω–æ –¥–æ 0; –º–æ–∂–Ω–∞ –¥–æ—Ä–æ–±–∏—Ç–∏ –ø—ñ–∑–Ω—ñ—à–µ)
  v_current_streak := 0;
  v_longest_streak := 0;

  return query select v_total, v_hours, v_current_streak, v_longest_streak, v_categories, v_join,
                       v_level_name, v_level_emoji, v_progress_to_next, v_progress_percentage;
end; $$;

